// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: DiscordProtos.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Discord_UserSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var versions: Discord_UserSettings.Versions {
    get {return _storage._versions ?? Discord_UserSettings.Versions()}
    set {_uniqueStorage()._versions = newValue}
  }
  /// Returns true if `versions` has been explicitly set.
  public var hasVersions: Bool {return _storage._versions != nil}
  /// Clears the value of `versions`. Subsequent reads from it will return its default value.
  public mutating func clearVersions() {_uniqueStorage()._versions = nil}

  public var inbox: InboxSettings {
    get {return _storage._inbox ?? InboxSettings()}
    set {_uniqueStorage()._inbox = newValue}
  }
  /// Returns true if `inbox` has been explicitly set.
  public var hasInbox: Bool {return _storage._inbox != nil}
  /// Clears the value of `inbox`. Subsequent reads from it will return its default value.
  public mutating func clearInbox() {_uniqueStorage()._inbox = nil}

  public var guilds: AllGuildSettings {
    get {return _storage._guilds ?? AllGuildSettings()}
    set {_uniqueStorage()._guilds = newValue}
  }
  /// Returns true if `guilds` has been explicitly set.
  public var hasGuilds: Bool {return _storage._guilds != nil}
  /// Clears the value of `guilds`. Subsequent reads from it will return its default value.
  public mutating func clearGuilds() {_uniqueStorage()._guilds = nil}

  public var userContent: UserContentSettings {
    get {return _storage._userContent ?? UserContentSettings()}
    set {_uniqueStorage()._userContent = newValue}
  }
  /// Returns true if `userContent` has been explicitly set.
  public var hasUserContent: Bool {return _storage._userContent != nil}
  /// Clears the value of `userContent`. Subsequent reads from it will return its default value.
  public mutating func clearUserContent() {_uniqueStorage()._userContent = nil}

  public var voiceAndVideo: VoiceAndVideoSettings {
    get {return _storage._voiceAndVideo ?? VoiceAndVideoSettings()}
    set {_uniqueStorage()._voiceAndVideo = newValue}
  }
  /// Returns true if `voiceAndVideo` has been explicitly set.
  public var hasVoiceAndVideo: Bool {return _storage._voiceAndVideo != nil}
  /// Clears the value of `voiceAndVideo`. Subsequent reads from it will return its default value.
  public mutating func clearVoiceAndVideo() {_uniqueStorage()._voiceAndVideo = nil}

  public var textAndImages: TextAndImagesSettings {
    get {return _storage._textAndImages ?? TextAndImagesSettings()}
    set {_uniqueStorage()._textAndImages = newValue}
  }
  /// Returns true if `textAndImages` has been explicitly set.
  public var hasTextAndImages: Bool {return _storage._textAndImages != nil}
  /// Clears the value of `textAndImages`. Subsequent reads from it will return its default value.
  public mutating func clearTextAndImages() {_uniqueStorage()._textAndImages = nil}

  public var notifications: NotificationSettings {
    get {return _storage._notifications ?? NotificationSettings()}
    set {_uniqueStorage()._notifications = newValue}
  }
  /// Returns true if `notifications` has been explicitly set.
  public var hasNotifications: Bool {return _storage._notifications != nil}
  /// Clears the value of `notifications`. Subsequent reads from it will return its default value.
  public mutating func clearNotifications() {_uniqueStorage()._notifications = nil}

  public var privacySettings: PrivacySettings {
    get {return _storage._privacySettings ?? PrivacySettings()}
    set {_uniqueStorage()._privacySettings = newValue}
  }
  /// Returns true if `privacySettings` has been explicitly set.
  public var hasPrivacySettings: Bool {return _storage._privacySettings != nil}
  /// Clears the value of `privacySettings`. Subsequent reads from it will return its default value.
  public mutating func clearPrivacySettings() {_uniqueStorage()._privacySettings = nil}

  public var debug: DebugSettings {
    get {return _storage._debug ?? DebugSettings()}
    set {_uniqueStorage()._debug = newValue}
  }
  /// Returns true if `debug` has been explicitly set.
  public var hasDebug: Bool {return _storage._debug != nil}
  /// Clears the value of `debug`. Subsequent reads from it will return its default value.
  public mutating func clearDebug() {_uniqueStorage()._debug = nil}

  public var gameLibrary: GameLibrarySettings {
    get {return _storage._gameLibrary ?? GameLibrarySettings()}
    set {_uniqueStorage()._gameLibrary = newValue}
  }
  /// Returns true if `gameLibrary` has been explicitly set.
  public var hasGameLibrary: Bool {return _storage._gameLibrary != nil}
  /// Clears the value of `gameLibrary`. Subsequent reads from it will return its default value.
  public mutating func clearGameLibrary() {_uniqueStorage()._gameLibrary = nil}

  public var status: StatusSettings {
    get {return _storage._status ?? StatusSettings()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  public var localization: LocalizationSettings {
    get {return _storage._localization ?? LocalizationSettings()}
    set {_uniqueStorage()._localization = newValue}
  }
  /// Returns true if `localization` has been explicitly set.
  public var hasLocalization: Bool {return _storage._localization != nil}
  /// Clears the value of `localization`. Subsequent reads from it will return its default value.
  public mutating func clearLocalization() {_uniqueStorage()._localization = nil}

  public var appearance: AppearanceSettings {
    get {return _storage._appearance ?? AppearanceSettings()}
    set {_uniqueStorage()._appearance = newValue}
  }
  /// Returns true if `appearance` has been explicitly set.
  public var hasAppearance: Bool {return _storage._appearance != nil}
  /// Clears the value of `appearance`. Subsequent reads from it will return its default value.
  public mutating func clearAppearance() {_uniqueStorage()._appearance = nil}

  public var guildFolders: GuildFolders {
    get {return _storage._guildFolders ?? GuildFolders()}
    set {_uniqueStorage()._guildFolders = newValue}
  }
  /// Returns true if `guildFolders` has been explicitly set.
  public var hasGuildFolders: Bool {return _storage._guildFolders != nil}
  /// Clears the value of `guildFolders`. Subsequent reads from it will return its default value.
  public mutating func clearGuildFolders() {_uniqueStorage()._guildFolders = nil}

  public var favoriteChannels: Favorites {
    get {return _storage._favoriteChannels ?? Favorites()}
    set {_uniqueStorage()._favoriteChannels = newValue}
  }
  /// Returns true if `favoriteChannels` has been explicitly set.
  public var hasFavoriteChannels: Bool {return _storage._favoriteChannels != nil}
  /// Clears the value of `favoriteChannels`. Subsequent reads from it will return its default value.
  public mutating func clearFavoriteChannels() {_uniqueStorage()._favoriteChannels = nil}

  public var audioContextSettings: AudioSettings {
    get {return _storage._audioContextSettings ?? AudioSettings()}
    set {_uniqueStorage()._audioContextSettings = newValue}
  }
  /// Returns true if `audioContextSettings` has been explicitly set.
  public var hasAudioContextSettings: Bool {return _storage._audioContextSettings != nil}
  /// Clears the value of `audioContextSettings`. Subsequent reads from it will return its default value.
  public mutating func clearAudioContextSettings() {_uniqueStorage()._audioContextSettings = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Versions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var clientVersion: UInt32 = 0

    public var serverVersion: UInt32 = 0

    public var dataVersion: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Discord_UserSettings: @unchecked Sendable {}
extension Discord_UserSettings.Versions: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "Discord"

extension Discord_UserSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "versions"),
    2: .same(proto: "inbox"),
    3: .same(proto: "guilds"),
    4: .same(proto: "userContent"),
    5: .same(proto: "voiceAndVideo"),
    6: .same(proto: "textAndImages"),
    7: .same(proto: "notifications"),
    8: .same(proto: "privacySettings"),
    9: .same(proto: "debug"),
    10: .same(proto: "gameLibrary"),
    11: .same(proto: "status"),
    12: .same(proto: "localization"),
    13: .same(proto: "appearance"),
    14: .same(proto: "guildFolders"),
    15: .same(proto: "favoriteChannels"),
    16: .same(proto: "audioContextSettings"),
  ]

  fileprivate class _StorageClass {
    var _versions: Discord_UserSettings.Versions? = nil
    var _inbox: InboxSettings? = nil
    var _guilds: AllGuildSettings? = nil
    var _userContent: UserContentSettings? = nil
    var _voiceAndVideo: VoiceAndVideoSettings? = nil
    var _textAndImages: TextAndImagesSettings? = nil
    var _notifications: NotificationSettings? = nil
    var _privacySettings: PrivacySettings? = nil
    var _debug: DebugSettings? = nil
    var _gameLibrary: GameLibrarySettings? = nil
    var _status: StatusSettings? = nil
    var _localization: LocalizationSettings? = nil
    var _appearance: AppearanceSettings? = nil
    var _guildFolders: GuildFolders? = nil
    var _favoriteChannels: Favorites? = nil
    var _audioContextSettings: AudioSettings? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _versions = source._versions
      _inbox = source._inbox
      _guilds = source._guilds
      _userContent = source._userContent
      _voiceAndVideo = source._voiceAndVideo
      _textAndImages = source._textAndImages
      _notifications = source._notifications
      _privacySettings = source._privacySettings
      _debug = source._debug
      _gameLibrary = source._gameLibrary
      _status = source._status
      _localization = source._localization
      _appearance = source._appearance
      _guildFolders = source._guildFolders
      _favoriteChannels = source._favoriteChannels
      _audioContextSettings = source._audioContextSettings
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._versions) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._inbox) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._guilds) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._userContent) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._voiceAndVideo) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._textAndImages) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._notifications) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._privacySettings) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._debug) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._gameLibrary) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._localization) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._appearance) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._guildFolders) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._favoriteChannels) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._audioContextSettings) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._versions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._inbox {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._guilds {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._userContent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._voiceAndVideo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._textAndImages {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._notifications {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._privacySettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._debug {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._gameLibrary {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._localization {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._appearance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._guildFolders {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._favoriteChannels {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._audioContextSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Discord_UserSettings, rhs: Discord_UserSettings) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._versions != rhs_storage._versions {return false}
        if _storage._inbox != rhs_storage._inbox {return false}
        if _storage._guilds != rhs_storage._guilds {return false}
        if _storage._userContent != rhs_storage._userContent {return false}
        if _storage._voiceAndVideo != rhs_storage._voiceAndVideo {return false}
        if _storage._textAndImages != rhs_storage._textAndImages {return false}
        if _storage._notifications != rhs_storage._notifications {return false}
        if _storage._privacySettings != rhs_storage._privacySettings {return false}
        if _storage._debug != rhs_storage._debug {return false}
        if _storage._gameLibrary != rhs_storage._gameLibrary {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._localization != rhs_storage._localization {return false}
        if _storage._appearance != rhs_storage._appearance {return false}
        if _storage._guildFolders != rhs_storage._guildFolders {return false}
        if _storage._favoriteChannels != rhs_storage._favoriteChannels {return false}
        if _storage._audioContextSettings != rhs_storage._audioContextSettings {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Discord_UserSettings.Versions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Discord_UserSettings.protoMessageName + ".Versions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_version"),
    2: .standard(proto: "server_version"),
    3: .standard(proto: "data_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.clientVersion) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.serverVersion) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.dataVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.clientVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.clientVersion, fieldNumber: 1)
    }
    if self.serverVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.serverVersion, fieldNumber: 2)
    }
    if self.dataVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.dataVersion, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Discord_UserSettings.Versions, rhs: Discord_UserSettings.Versions) -> Bool {
    if lhs.clientVersion != rhs.clientVersion {return false}
    if lhs.serverVersion != rhs.serverVersion {return false}
    if lhs.dataVersion != rhs.dataVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
